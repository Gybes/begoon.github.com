<html>
<head>
<title>Описание встроенного отладчика</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css"></head>

<body bgcolor="#FFFFFF" background="jpgs/exptextb.jpg">
<div align="center"></div>
<h2 align="center">Встроенный отладчик (РАДИО-86РК отладчик)</h2>
<hr>
<h3>Что мы имеем:</h3>
<ol start="0">
  <li><a href="#intro">Введение</a> </li>
  <li><a href="#keyboard">Краткое описание клавиш</a> </li>
  <li><a href="#digits">Ввод чисел</a> </li>
  <li><a href="#registers"> Редактирование регистров </a></li>
  <li> <a href="#memory">Редактирование памяти</a> </li>
  <li><a href="#dumps"> Загрузка и снятие дампов памяти</a> </li>
  <li><a href="#exceptions">Исключительные ситуации</a> </li>
  <li><a href="#delay"> Задержка</a> </li>
  <li><a href="#edittraps">Редактирование ловушек</a> </li>
  <li><a href="#traps">Механизм ловушек </a></li>
</ol>
<hr noshade>
<h3> <a name="intro"></a>0. Введение<br>
</h3>
<p> Здесь Вы найдете описание только особенностей встроенного отладчика от подобного 
  рода отладчиков, и если Вы можете совладать с Turbo Debugger'ом, AFD или, наконец, 
  с SoftIce'ом, то Вы без труда освоите все возможности этого отладчика. 
<p> Встроенный в эмулятор отладчик имеет весьма разнообразные возможности по трассировке 
  кода, механизму ловушек, снятию дампов с памяти и модификации памяти. Правда 
  из-за ориентации отладчика на особенности РК и на работу с программами для РК, 
  Вы не найдете в нем функций поиска и сравнения &#150; если очень надо, то выйдите 
  в Монитор и воспользуйтесь его командами для этого. 
<p> Отладчик вызывается из эмулятора клавишей F12 (только если Вы запустили вариант 
  эмулятора СО встроенным отладчиком). 
<p>Вот примерный вид экрана встроенного отладчика:
<p>&nbsp; 
<table width="100%" border="2">
  <tr> 
    <td colspan="3"><b><tt>Окно регистров (0)</tt></b></td>
  </tr>
  <tr> 
    <td colspan="3"><b><tt>Окно последней команды (1)</tt></b></td>
  </tr>
  <tr> 
    <td width="71%" valign="top"> 
      <p><b><tt>Окно дизассемблера (2)</tt></b></p>
      <p>&nbsp;</p>
      <p><b><tt><br>
        </tt></b></p>
      <p>&nbsp;</p>
    </td>
    <td colspan="2" valign="top"><b><tt>Окно ловушек (3) </tt></b></td>
  </tr>
  <tr> 
    <td colspan="2" valign="top"><b><tt>Окно данных (4)</tt></b></td>
    <td width="18%" valign="top"> 
      <p><b><tt>Окно <br>
        стека (5)</tt></b></p>
      <p>&nbsp;</p>
    </td>
  </tr>
  <tr> 
    <td colspan="3"><b><tt>Окно ввода (6)</tt></b></td>
  </tr>
  <tr> 
    <td colspan="3"><b><tt>Строка подсказки (7)</tt></b></td>
  </tr>
</table>
<ol start="0">
  <li> значения всех регистров и управляющих флагов процессора</li>
  <li> последняя исполненная команда</li>
  <li> дизассемблированный фрагмент памяти (если какой-либо команде в этом окне 
    соответствует одна из активных ловушек, то данные об этой ловушке выводится 
    вместе с командой)</li>
  <li> информация об активных ловушках (последняя сработавшая ловушка подсвечивается 
    белым цветом)</li>
  <li> дамп фрагмента памяти</li>
  <li> вершина стека, начиная от SP</li>
  <li> окно ввода и редактирования</li>
  <li> строка подсказки</li>
</ol>
<hr>
<h3><a name="keyboard"></a>1. Краткое описание клавиш</h3>
<p><br>
  По основным клавишам этот отладчик очень похож на Turbo Debugger. 
<p>Краткое описание клавиш:
<p>F1<br>
  -- <br>
  Принудительная передача управления на адрес f800h (рестарт Монитора). Сделано 
  для выхода из зацикливания при выполнении процессором bad opcode (<a href="#exceptions">глава 
  &quot;Исключительные ситуации&quot;</a>). 
<p><a href="#traps">F2</a><br>
  -- <br>
  Установка ловушки (EXEC,P) на текущий адрес (<a href="#traps">глава &quot;Ловушки&quot;</a>). 
<p><a href="#traps">F4</a><br>
  -- <br>
  Выполнение программы до текущего адреса. Выполняется установкой ловушки (EXEC,T) 
  на текущий адрес и передачей управления программе (<a href="#traps">глава &quot;Ловушки&quot;</a>). 
<p>F5<br>
  -- <br>
  Экран эмулятора. 
<p><a href="#delay">F6</a><br>
  -- <br>
  Ввод задержки (<a href="#delay">глава &quot;Задержка&quot;</a>). 
<p><a href="#traps">F7</a><br>
  -- <br>
  Выполнение ОДНОЙ текущей команды программы и ГАРАНТИРОВАННОЕ возвращение в отладчик. 
<p><a href="#traps">F8</a><br>
  -- <br>
  Выполнение ОДНОЙ текущей команды программы без входа в подпрограмму командами 
  CALL/Cxx. Если текущая команда не является одной из серии команд CALL/Cxx, то 
  возвращение в отладчик гарантировано, иначе (при выполнении одной из команд 
  CALL/Cxx) возвращение в отладчик после выполнения этой команды может и не последовать, 
  если вызванная подпрограмма корректно не закончит работу одной из команд RET/Rxx. 
  Такое поведение связано с тем, что обход вызова подпрограммы производится установкой 
  ловушки типа (EXEC,T) на команду, следующую за командой вызова подпрограммы 
  со всеми вытекающими последствиями. Поэтому, если возврата в отладчик после 
  выполнения команды CALL/Cxx не последовало, то в списке активных ловушек может 
  остаться установленная ловушка. 
<p>F9<br>
  -- <br>
  Передача управления программе. 
<p><a href="#traps">F10</a><br>
  -- <br>
  Выполнение программы по первой команды RET. Выполняется установкой ловушки 0000C900(INSTR,T) 
  и передачей управления программе.<br>
  ВНИМАНИЕ: условные команды Rxx не обрабатываются, что следует из формата ловушки 
  000C900(INSTR,T). 
<p><a href="#digits">G</a><br>
  -- <br>
  Переход на введенный адрес в окне кода (<a href="#digits">глава &quot;Ввод чисел&quot;</a>) 
<p><a href="#digits">D</a><br>
  -- <br>
  Переход на введенный адрес в окне данных (<a href="#digits">глава &quot;Ввод 
  чисел&quot;</a>) 
<p><a href="#keyR">R</a><br>
  -- <br>
  Редактирование байтовых регистров (<a href="#registers">глава &quot;Редактирование 
  регистров&quot;</a>) 
<p><a href="#keyW">W</a><br>
  -- <br>
  Редактирование регистровых пар (<a href="#registers">глава &quot;Редактирование 
  регистров&quot;</a>) 
<p><a href="#keyF">F</a><br>
  -- <br>
  Редактирование флагов (<a href="#registers">глава &quot;Редактирование регистров&quot;</a>) 
<p><a href="#memory">E</a><br>
  -- <br>
  Редактирование памяти в окне данных (4) (<a href="#memory">глава &quot;Редактирование 
  памяти&quot;</a>) 
<p><a href="#traps">B</a><br>
  -- <br>
  Редактирование ловушек (<a href="#traps">глава &quot;Редактирование ловушек&quot;</a>) 
<p><a href="#dumps">Grey '*'</a><br>
  ------ <br>
  Загрузка фрагмента памяти из файла (<a href="#dumps">глава &quot;Загрузка и 
  снятие дампов памяти&quot;</a>) 
<p><a href="#dumps">Grey '-'</a><br>
  ------ <br>
  Запись фрагмента памяти в файл (<a href="#dumps">глава &quot;Загрузка и снятие 
  дампов памяти&quot;</a>) 
<p>Grey '+'<br>
  ------ <br>
  Вывод таблицы символов РК. 
<p><a href="dox.html#kbdtable">NumLock</a><br>
  ------ <br>
  Вывод помощи по раскладке клавиатуры и состоянию эмулятора 
<p>ALT-X<br>
  ---- <br>
  Немедленный выход из эмулятора 
<hr noshade>
<p>
<h3><a name="digits"></a>2. Ввод чисел<br>
</h3>
<p> При запросе на ввод любой числовой информации в окне ввода Вы можете вводить 
  числа в интервале от 0 до 0xffffffff, которые будут урезаться в зависимости 
  от смысла вводимого числа. Числа вводятся <em><strong>ТОЛЬКО</strong></em> в 
  шестнадцатеричной системе. Клавиша ESC отменяет результат редактирования и прерывает 
  его процесс. Клавиша ENTER тоже прекращает редактирование, но изменения вступают 
  в силу. 
<p>При редактировании, нажав PGUP, можно восстановить начальное значение редактируемого 
  числа. При вводе можно подставлять значения регистровых пар PC, SP, HL, DE, 
  BC или AF. Для этого надо ввести имя регистровой пары, предварив ее символом 
  '#' (например, #DE), и нажать ENTER для завершения редактирования. Еще можно 
  подставлять значение слова (WORD) из памяти, адресуемого регистровыми парами 
  (хотя для регистровой пары AF вряд ли это будет иметь смысл). Для этого тоже 
  вводится имя регистровой пары, предваренное символом '&amp;' (например, &amp;BC).
<p> Наконец, можно подставить значение указанной ловушки. Для этого введите символ 
  '.' и затем введите номер ловушки (например .4). Если ловушка с таким номером 
  пуста, то результат ввода останется неизмененным.<br>
  Ну и самая последняя возможная подстановка значения &#150; это использования адреса 
  последней выполненной операции (окно 1). Для этого используйте слово 'last'. 
  Это слово надо использовать по аналогии с регистровыми парами, то есть либо 
  как #last для непосредственной подстановки и &amp;last &#150; для косвенной. 
<p><br>
<hr noshade>
<h3><a name="registers"></a>3. Редактирование регистров</h3>
<p><br>
  Редактирование регистров вызывается из отладчика кнопками 
<ul>
  <li><a name="keyR"></a>'R' &#150; для байтовых регистров,</li>
  <li><a name="keyW"></a>'W' &#150; для регистровых пар </li>
  <li><a name="keyF"></a>'F' &#150; для отдельных флагов.</li>
</ul>
<p> В первых двух случаях Вы выбираете регистр и затем вводите его значение. При 
  выборе регистров можно использовать &quot;горячие&quot; клавиши &#150; цифры от 
  '1' и далее &#150; в зависимости от номера регистра или регистровой пары в меню. 
  Не забывайте, что при вводе чисел можно пользоваться подстановками значений 
  других регистров и памяти, адресуемой регистрами. При редактировании же отдельных 
  флагов Вы просто выбираете флаг и затем его значение инвертируется. При выборе 
  флагов можно пользоваться &quot;горячими&quot; клавишами &#150; первыми буквами 
  названий флагов &#150; C, N, S и Z соответственно. </p>
<hr noshade>
<h3> <a name="memory"></a>4. Редактирование памяти</h3>
<p>Нажав 'E', Вы можете редактировать память либо в HEX-режиме, либо в символьном, 
  переключаясь между ними клавишей TAB. Выход из редактирования &#150; ESCAPE. 
<hr noshade>
<h3> <a name="dumps"></a>5. Загрузка и снятие дампов памяти<br>
</h3>
<p> Клавишами Grey '*' и Grey '-' можно записывать фрагменты памяти на диск и 
  считывать их обратно.<br>
  При записи фрагмента памяти Вы вводите имя файла или выбираете уже существующий 
  (он перезапишется), затем вводите начальный и конечный адреса записываемого 
  фрагмента. После этого Вы выбираете тип файла для<br>
  записываемого фрагмента. Если это 'Dump', то это будет просто точная байтовая 
  копия указанного куска памяти, которую затем можно будет загрузить через Grey 
  '-'. А при 'Monitor file' фрагмент будет записан в формате<br>
  Монитора (<a href="dox.html#out">глава &quot;Эмуляция записи&quot;</a>) и пригоден 
  для дальнейшей загрузки и РК командой Монитора 'I'. При загрузке фрагмента памяти 
  (например, после сохранения в режиме 'Dump') Вы просто выбираете файл и вводите 
  стартовый адрес загрузки. 
<hr>
<h3> <a name="exceptions"></a>6. Исключительные ситуации<br>
</h3>
<p> На данный момент единственной исключительной ситуацией является попытка выполнения 
  эмулятором недопустимой команды (bad opcode). Если в меню настроек флаг 'КОНТРОЛЬ 
  bad opcodes' в состоянии ВКЛ, то<br>
  при выполнении недопустимой команды получает управление отладчик и далее Вы 
  сами решаете, что делать (можно, например, нажать F1 и перезапустить &quot;Монитор&quot;). 
  Если отладчик недоступен (Вы запустили эмулятор без встроенного отладчика), 
  то поведение эмулятора будет аналогично выполнению команды HLT. Перезапустить 
  эмулятор в этом случае можно, например, клавишей RESET (F11). Если 'КОНТРОЛЬ 
  bad opcodes' в состоянии ВЫКЛ, то эмулятор просто игнорирует этот 'bad opcode' 
  и начинает выполнение следующей за ним инструкции. 
<hr>
<h3> <a name="delay"></a>7. Задержка<br>
</h3>
<p> Через клавишу F6 в отладчике Вы можете вводить задержку работы эмулятора (также 
  Вы можете менять эту задержку в <a href="dox.html#menu">меню настроек эмулятора</a>).<br>
  По умолчанию &#150; это 1. Задержка 1 является минимальной, при которой сохраняется 
  &quot;<a href="commands.html">растактовка</a>&quot; команд i8080 (по tick'ам). 
  При 0 Вы получите максимальную скорость, но время выполнения команд будет не 
  сбалансировано относительно документации на i8080. Увеличивая задержку, Вы можете 
  замедлять эмулятор. На моем p200/mmx при задержке 1 эмулятор работает в ~2.5 
  раза быстрее &quot;родного&quot; РК. 
<hr noshade>
<h3> <a name="edittraps"></a>8. Редактирование ловушек (<a href="#traps">глава 
  &quot;Ловушки&quot;</a>)<br>
</h3>
<p> Нажав 'B', Вы выбираете ловушку. Затем Вы можете изменить режим ловушки (поле 
  mode) &#150; Empty (этим Вы просто стираете ловушку и редактирование заканчивается), 
  Permanent или Temp. В меню изменения режима ловушки можно пользоваться горячими 
  клавишами E, P и T соответственно.
<p> После, Вы выбираете тип ловушки (поле type) &#150; EXEC, ACCESS, READ, WRITE, 
  INSTR, IO/IN, IO/OUT. Здесь горячие клавиши E, A, R, W, I, N и T соответственно.<br>
  Ну и в конце, Вы вводите данные ловушки (поле info) &#150; число от 0 до ffffffffh.<br>
  Сокращенно, данные о ловушке (в окне ловушек или в окне кода) представляются 
  в виде: 
<pre><b>XXXXXXXX(type, mode)
   | | |
   | | +&#150;&#150;&gt; поле mode (P-Permanent, T-Temp)
   | +&#150;&#150;&#150;&#150;&#150;&gt; поле type (INSTR, EXEC, ACCESS, READ,
   | WRITE, IO/IN, IO/OUT)
   +&#150;&#150;&#150;&#150;&#150;&#150;&#150;&#150;&gt; поле info от 0 до 0xffffffff</b></pre>
<pre>Пример:
   0000F836(EXEC, T)</pre>
<hr noshade>
<h3> <a name="traps"></a>9. Ловушки<br>
</h3>
<p> Ловушки были введены в эмулятор для его собственной отладки и ломания игрушек.<br>
  Редактировать ловушки можно клавишей 'B' в отладчике.<br>
  Каждая ловушка (всего их 10 &#150; к чему больше?) имеет 3 поля данных: 
<ol>
  <li> Mode (режим)<br>
    <em>Empty (отключена &#150; в этом состоянии ловушки просто как бы нет), Permanent 
    (постоянная &#150; активна до тех пор, пока Вы ее ВРУЧНУЮ не отключите) и Temp 
    (временная &#150; самоотключается при первом ее срабатывании).<br>
    <br>
    </em></li>
  <li>2. Type (тип)<br>
    <br>
    <em>INSTR &#150; на инструкцию процессора с указанной маской аргументов.<br>
    EXEC &#150; на исполнения по указанному адресу<br>
    ACCESS &#150; на чтение/запись байта по указанному адресу<br>
    READ &#150; на чтение байта по указанному адресу<br>
    WRITE &#150; на запись байта по указанному адресу<br>
    IO/IN &#150; на ввод из указанного порта<br>
    IO/OUT &#150; на вывод из указанного порта<br>
    <br>
    </em></li>
  <li> Info (данные по ловушке), размер этого поля 4 байта<br>
    <br>
    <em>Для ловушки INSTR данные в поле info задаются по принципу дизассемблера. 
    Вот условие срабатывания ловушки в нотации языка C (op &#150; код текущей команды): 
    <br>
    <br>
    <code>cond = op &amp; ~(info &amp; 0xff)) == info&gt;&gt;8 <br>
    </code><br>
    Если <code>cond==0</code>, то ловушка НЕ сработала, иначе &#150; сработала. <br>
    <br>
    Попросту говоря, в старшем байте младшего слова поля info Вы задаете маску 
    нужной команды С ЗАМАСКИРОВАННЫМИ нужными аргументами, а в младшем байте младшего 
    слова поля info &#150; задаете НЕ ИНВЕРТИРОВАННУЮ маску нужных аргументов. Если 
    Вы ищете команду с ТОЧНЫМ опкодом (либо команда не имеет аргументов вообще, 
    либо Вам нужна команда с конкретными значениями параметров), то маска аргументов 
    равна 0, а маска команды просто равна опкоду искомой команды.<br>
    Маски команд и их аргументов можно определить, зная коды команд процессора.</em> 
  </li>
</ol>
<h4> Примеры (пусть здесь режим будет Temp): </h4>
<p> 1. Команда RET (C9) &#150; info=С900, 0000C900(INSTR, T)<br>
  2. Команда MOV r1, r2 &#150; info=403F, 0000403F(INSTR, T)<br>
  3. Команда LXI rp, xxxx &#150; info=0130, 00000130(INSTR, T)
<p> Значение старшего слова поля info для ловушки типа INSTR на имеет<br>
  значения.<br>
  Ловушки типа INSTR срабатывают ДО исполнения инструкции.
<p> Для остальных типов ловушек, задавая info, Вы просто задаете адрес<br>
  срабатывания для ловушек по памяти (от 0 до 0ffffh) или номер порта для<br>
  ловушек на ввод/вывод (от 0 до 00ffh).<br>
  Если старшее слово поля info (кроме ловушек типа INSTR) равно нулю, то<br>
  ловушка срабатывает прb ТОЧНОМ совпадении текущего анализируемого адреса<br>
  или номера порта, по которому идет обращение.<br>
  Если старшее полуслово поля info не 0, то ловушка срабатывает по<br>
  диапазону адресов. Вот условие срабатывания в этом случае (addr &#150;<br>
  анализируемый адрес памяти или порта) в нотации языка C:
<p> <kbd>cond = addr &gt;= (info &amp; 0xffff) &amp;&amp; addr &lt;= info&gt;&gt;16 
  </kbd>
<p> Если cond == 0, то ловушка НЕ сработала, иначе &#150; сработала.<br>
  В общем, здесь Вы задаете начальный адрес диапазона срабатывания во<br>
  младшем cлове поля info и конечный &#150; в старшем.
<p> Примеры (пусть здесь режим будет Temp):
<p> 1. 0000F836(EXEC, T) &#150; исполнение по адресу F836<br>
  2. 00000020(IO/OUT, T) &#150; вывод в порт 20<br>
  3. 2FFF1000(WRITE, T) &#150; запись по адресам от 1000 до 2FFF<br>
  4. 00400020(IO/IN, T) &#150; чтение из портов от 20 до 40
<p> Все ловушки (кроме типа INSTR) срабатывают ПОСЛЕ найденной команды.
<p><br>
<hr>
<p>Если Вы хотите узнать о том, как ломать РК'шные игры этим отладчикам, то смотрите 
  <a href="hackgames.html">сюда</a>. </p>
<p align="center"><br>
  Не стесняйтесь писАть <a href="mailto:alexander@demin.ws"><img src="gifs/email.gif" align="absmiddle" name="feedback" alt="Пишите мне" border="0"></a>, 
  если возникают какие-либо вопросы. 
<p align="right"><a href="hackgames.html"><img src="gifs/back1.gif" name="back" alt="back" border="0"></a><br>
</p>
</body>
</html>
