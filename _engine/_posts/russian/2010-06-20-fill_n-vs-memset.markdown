---
layout: post
title: "fill_n vs memset"
language: russian
date: 2010-06-20 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2010/06/filln-vs-memset.html
categories:
- cplusplus
- russian
---
В данный момент на текущей работе я занимаюсь тем, что называется - высокоуровневое серверное программирование на С++. У меня уже есть все необходимые библиотеки низкого уровня и среднего (более того, если я отказываюсь по какой-то причине от готовой библиотеки, меня могут потом попросить это объяснить), и огромное количество библиотек высокого уровня, уровня бизнес-логики. К чему все это?

А вот к чему. Если разобраться, что я могу писать код вообще без С-шных штучек типа массивов, malloc/free, старого способа приведения типов, строчек с нулем на конце и т.д. Получается, что мой диалект С++ можно урезать на тему всего, что я перечислил. Просто убрать, и все.

И от этого будет только польза. Сколько ошибок потенциально я НЕ сделаю в арифметике указателей (ее просто не будет)? Вместо того, чтобы мотивировать человека "разумно использовать наследия С в С++", их надо просто выключить. Конечно, сразу сузится и круг решаемых задач, но мой, кстати, не самый узкий круг, можно покрыть таким вот урезанным в сторону "правильного" С++ диалектом С++.

Например, как мне кажется, функция `memset()` в мире С++ в целом годится разве что для обнуления. Использование какой-либо иной константы-заполнителя принципиально приближает нас к проблемам с памятью. Хотите, например, "эффективно" заполнить строку пробелами, и зарядите для этого `memset()`, а потом вам неожиданно придется работать с многобайтовыми кодировками, и этот пробел, записанный через `memset()`, может стать источником проблем.

Так что используйте алгоритм `fill_n()` вместо `memset()`. Может быть неэффективен? Может, а может и нет. Зато уж точно безопасен с точки зрения типизации.
