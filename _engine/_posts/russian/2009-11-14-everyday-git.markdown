---
layout: post
title: "git в ежедневной работе"
language: russian
date: 2009-11-14 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2009/11/git-cvs.html
categories:
- git
- russian
---
По долгу работы мне приходится участвовать процедуре следующего толка: есть ветка исходников, стабильность которой имеет чудовищную важность. Там не то, что сломать билд нельзя, там каждый коммит проходит несколько стадий автоматических проверок (компиляция на разных платформах разными компиляторами, прогон разнообразных анализаторов и т.д.) плюс надо получить подтверждение у как минимум четырех/пяти человек, которые должны проверить твой коммит. Процедура мучительная и долгая даже с технической точки зрения. Более того, процедура выстраивалась годами и основана на очень древней системе контроля версий (не будем называть ее всуе), поэтому возможности слияния и разрешения конфликтов в основном ручные. Она умеет нормально делать только check-out и check-in. 

Как следствие того, что каждый коммит готовится, отлаживается и проверяется ощутимое время (благо это только bug fix'ы, размер которых обычно невелик), и даже формальная сторона вопроса может занять пару дней, и очень часто случается, что когда дело доходит непосредственно до команды "commit", все оканчивается конфликтом, так как кто-то уже успел потрогать твой кусок кода и залить это на сервер. И надо ручками сливать обновленную версию со своими изменениями. А если файл не один, то начинается головная боль. 

Так как я только недавно в этой теме, то после второго же коммита решил упростить себе жизнь в плане слияния при конфликте. 

Расчехлил я [git][], и теперь все выглядит так: каждый мой багфикс живет в отдельном репозитории git (фактически, каталог) с двумя ветками. В одной я независимо работаю над исправлениями, веду git'ом историю этой работы, а во вторую ветку периодически синхронизирую состояние исходников из главного репозитория и сливаю с ними свою ветку одной единственной командой "git merge". 

[git]: http://git-scm.org/

В плане распределенных SCM я сейчас в основном работаю с mercurial, так как Google Code его поддерживает. Но все таки git - это невероятно мощный инструмент (правда когда в рабочем процессе не фигурирует Windows, ибо виндовая версия git'а портирована крайне криво). 

По началу многое запутывает. Меня по первости крайне сбивала с толку идея staging area (или его еще называют - index). Эдакое промежуточное звено между локальными изменениями и самим репозиторием. Получается, что [git diff][] может показывать три разные вещи: разницу между локальными изменениями и индексом (а не репозиторием - это будет по умолчанию, что обычно и вводит новичков в ступор), разницу между индексом и репозиторием и наконец разницу между локальными изменениями и репозиторием. Индекс (или staging area) позволяет при коммите выбирать, что именно из локальных файлов надо закоммитить, а не все подряд. В коммите участвуют только файлы, находящиеся в индексе. Причем самое интересное, что можно включать в индекс куски измененных файлов (например, я добавил в файл два новых класса, но закоммитить могу только выборочно один из них). 

[git diff]: http://www.kernel.org/pub/software/scm/git/docs/git-diff.html

Вам уже нравится?

Или например, откат всех локальных изменений (очень частая операция) может быть выполнена как минимум двумя способами (через [git checkout][] и через [git reset][]), или откат уже сделанного коммита можно также провернуть минимум двумя путями ([git reset][] или [git revert][]) в зависимости от того, хотите ли вы видеть потом этот откат в истории. 

[git checkout]: http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html
[git reset]: http://www.kernel.org/pub/software/scm/git/docs/git-reset.html
[git revert]: http://www.kernel.org/pub/software/scm/git/docs/git-revert.html

Обилие функций и их некоторая непохожесть на общепринятые стандарты команд SCM немного обескураживают сначала. Но немного въехав в тему начинаешь ощущать всю мощь. Например, наличие staging area и git stash (когда можно временно заморозить текущее состояние, сделать какую-то быструю минутную работу и вернуться к основной теме) - весьма уникальные возможности git'a. 

В плане GUI - gitk дает все необходимое. 

Единственное, что надо выбрать по вкусу самостоятельно - это программу для проведения слияния при разрешении конфликта в графическом режиме. Тут у всех свои предпочтения. 

Использование правильных и удобных инструментов сильно ускоряет работу. И время, потраченное в начале на выбор и настройку правильных служебных программ однозначно окупится в будущем. 

Надеюсь, мне удалось привлечь в ряды пользователей git еще пару тройку энтузиастов. 

Однажды привыкнув с постоянному наличию под рукой контроля версий, хочется, чтобы она была везде. Даже при починке автомобиля. 

Посты по теме:

* [Какую распределенную систему контроля версий выбрать: Git, Bazaar или Mercurial?][]
* [Travis Swicegood, "Pragmatic Version Control using Git"][]

[Какую распределенную систему контроля версий выбрать: Git, Bazaar или Mercurial?]: /blog/russian/2009/05/21/what-version-control-to-choose/
[Travis Swicegood, "Pragmatic Version Control using Git"]: /blog/russian/2009/05/17/pragmatic-version-control-using-git/
