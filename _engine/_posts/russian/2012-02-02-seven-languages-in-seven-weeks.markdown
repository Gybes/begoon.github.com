---
layout: post
title: 'Брюс Тейт, "Семь языков за семь недель"'
language: russian
date: 2012-02-02 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2012/02/seven-languages-in-seven-weeks.html
categories: 
- book
- russian
---
Закончил ускоренное чтение по диагонали книги "[Seven languages in seven weeks][]", автор Bruce Tate.

[Seven languages in seven weeks]: http://pragprog.com/book/btlang/seven-languages-in-seven-weeks

{% img /images/covers/english/7-languages-in-7-weeks-cover.jpg %}

В моей версии это было "Семь языков за семь вечеров". Для каждого языка дается минимальное введение, которое имеет смысл только если язык для вас вообще новый. Еще приводятся мини интервью с создателями языков, и один из интересных задаваемых им вопросов - это "чтобы вы сделали в языке иначе, если б можно начать сначала".

Описываются языки:

* Ruby
* Io
* Prolog
* Scala
* Erlang
* Clojure
* Haskell

Обзор каждой главы - это мой субъективный взгляд на две вещи сразу: язык программирования и материал главы про него. Объясню почему - для знакомых языков вряд ли имеет смысл описывать сам язык. Может имеет смысл отметить интересные отличительные моменты. А вроде для неизученных, типа Пролога или Clojure, можно и остановиться немного на самом языке.

**Ruby**

Про Ruby ничего особенно из книги не вынес, так как вдумчиво читал "[Programming Ruby 1.9][]", после чего подсел на этот язык. Ruby - фантастический скриптовой язык. Каждый раз, когда пишу на нем, испытываю удовольствие примерно такое, когда я после Perl'а попробовал в первый раз PHP.

[Programming Ruby 1.9]: http://pragprog.com/book/ruby3/programming-ruby-1-9

Автор языка сказал в интервью, что, создавая бы язык заново сегодня, он бы хотел для многопоточности вместо традиционных потоков сделать модель [actor][].

[actor]: http://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2

В двух словах, Actor - это когда параллельные потоки разделяют ресурсы не через память и механизмы синхронизации типа мьютексов и семафоров, а через обмен сообщениями, прием и посылка которых обеспечиваются средой, и они встроены в синтаксис языка. Например, как в Scala, Go, Erlang, Io.

**Io**

[Io][] очень компактный, на мой взгляд эзотерический язык, основанный на прототипах, как JavaScript, когда нет четкого разделения между классами и объектами. Минимальный и очень простой синтаксис.

[Io]: http://iolanguage.com/

Интересный механизм многопоточности в дополнение к actor и coroutine (коллективная многозадачность, как в [Coroutines][Coroutines Lua] в Lua), называемый futures. "Future" - это вроде бы как обычный actor, поток запущенный работать параллельно. Но с одним отличием: как только создающий поток попытается воспользоваться результатом future, он будет заблокирован до тех пор, пока future не вычислит это значение.

[Coroutines Lua]: http://www.lua.org/manual/5.2/manual.html#2.6

Примерчик из книги:

{% codeblock lang:io %}
// Запускаем future
futureResult := URL with("http://google.com/") @fetch
writeln("Сразу начинаем делать что еще, пока future работает в фоне.")
// Эта строка будет выполнена сразу.
writeln("fetched ", futureResult size, " bytes")
// А вот эта строка будет заблокирована, пока future не выполнится.
{% endcodeblock %}

Идем дальше, **Prolog**.

Этого зверя я грызу давно. К счастью, благодаря освоению Erlang'а, я стал реально въезжать в функциональную тему в целом, и монстры типа Пролога или Хаскелла уже не за пределами понимания.

Так совпало, что глубина материала по Прологу легла точно для моего уровня. Задача восьми ферзей и поиска решений Судоку были для меня отличными примерами.

В двух словах: программа для Прологе - это набор фактов и связей между ними. Затем Пролог, выполняя программу, поиском в глубину обходит пространство решений и выбирает те, которые удовлетворяют всем заданным фактам и связям между ними.

Фактические программа поиска решения Судоку - это набор переменных, составляющих клетки поля Судоку, и набор правил - разнообразные суммирования по группам, по строками и столбцам (по правилам Судоку). И затем Пролог перебором ищет подходящие значения и комбинации переменных.

Конечно, это очень поверхностный взгляд, но который лично мне добавил много понимания.

Идем дальше, **Scala**.

Отмечу только отдельные факты, интересные мне.

Многопоточность на основе actors, то есть когда потоки обмениваются сообщениями. После Go и Erlang понимаешь как это удобно и правильно.

Про остальное - по-моему в Scalа есть все возможные свистелки и перделки, когда-либо придуманные в области языков программирования. В общем, если вы фанат Java VM, то надо брать полноценную книгу по Scala и грызть ее.

Идем далее, **Erlang**.

Тут тоже скажу мало, так как я фанат этого языка, и уровень этой книги мне был мал, но введение дается хорошее для ознакомления с функциональной сутью Erlang'а и его моделью многопоточности.

**Clojure**

Снова язык на основе Java VM. Clojure - это разновидность Лиспа со всеми вытекающими.

Интересная возможность языка, в общем-то не связанная с его лисповой сущностью - это STM, [software transactional memory][]. Это когда некий кусок кода в программе объявляется транзакцией, и он выполняется атомарно, либо все изменения откатываются.

[software transactional memory]: http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%B0%D1%8F_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C

Ну и под занавес, **Haskell**.

Хаскелл суров, и данная книга - это крайне минимальное введение, просто для запоминания слова Хаскелл. Я кое как осилил [отличную книгу Душкина][Функциональное программирование на языке Haskell] и "[Programming in Haskell][]", а сейчас читаю "[Real World Haskell][]", поэтому главу этой книги просто пролистал.

[Функциональное программирование на языке Haskell]: http://www.ozon.ru/context/detail/id/3039995/?partner=easy-coding
[Programming in Haskell]: http://www.amazon.co.uk/Programming-Haskell-Graham-Hutton/dp/0521692695
[Real World Haskell]: http://www.amazon.co.uk/Real-World-Haskell-Bryan-OSullivan/dp/0596514980

**Вывод**: книга 100% одноразовая, но, как говориться, раз не... полезно для кругозора и для программистских терок на кухне.
