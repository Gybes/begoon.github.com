---
layout: post
title: "Ссылка на временный объект в списке инициализации конструктора"
language: russian
date: 2010-10-29 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2010/10/blog-post_29.html
categories:
- cplusplus
- russian
---
Имеем два исходника:

{% codeblock lang:cpp %}
#include <iostream>

struct A {
  A();
  const int& i;
};

A::A() : i(123) {}

int main() {
  A a;
  std::cout << a.i << std::endl;
}
{% endcodeblock %}

и

{% codeblock lang:cpp %}
#include <iostream>

struct A {
  A() : i(123) {}
  const int& i;
};

int main() {
  A a;
  std::cout << a.i << std::endl;
}
{% endcodeblock %}

Будучи скомпилированными компилятором от Sun или GCC, эти два примера печатают разные результаты. И первый - неправильный. Студия же 2010, с настройками по умолчанию, дает предупреждение и генерирует код, работающий правильно (точнее, как ожидает программист) в обоих случаях.

Понятно, что код сам по себе несколько странный, так как сложно представить себе, кому может понадобиться инициализировать ссылку константой, которая передается в конструктор не извне, а создается временно во время обработки списка инициализации. Но вот на ошибку-опечатку вполне себе потянет.

Ко мне пример попал как результат анализа реального бага.
