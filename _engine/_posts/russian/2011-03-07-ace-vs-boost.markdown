---
layout: post
title: "ACE против boost или какую библиотеку выбрать"
language: russian
date: 2011-03-07 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2011/03/ace-boost.html
categories:
- russian
---
Есть задача: у нас есть несколько подсистем, для которых нужны следующие вещи:

* сокеты (клиентские, серверные, с SSL и без)
* [fork()][] для рождение дочернего процесса, который наследует сокет для обслуживания соединения
* потоки
* таймеры и задержки
* logger

Все перечисленное должно работать без исключения на Windows 2003/2008, Linux AS5+, AIX 5/6, Solaris (Intel/AMD), HP-UX v3.

[fork()]: http://ru.wikipedia.org/wiki/Fork

Для всего остального мы прекрасно довольствуемся STL.

Компиляторы только "родные" для каждой платформы (то есть, например, Cygwin не годится для Windows, и gcc только на Linux).

Мы давного используем [ACE][], как основную библиотеку. В ней есть все из выше сказанного, даже имитация fork под Windows, когда идентификатор сокета передается в символьном виде дочернему процессу через командную строку.

[ACE]: http://www.cs.wustl.edu/~schmidt/ACE.html

Вообще, `fork()` - это настоящая засада под Windows. Для его полноценной реализации нужно использовать недокументированные функции и структуры, как это делается в Cygwin, что, конечно, для нас неприемлемо в плане последующей поддержки. Что еще усугбляет ситуацию - нет возможности отказаться от мульти-процессной модели и просто перейти на потоки (поэтому и нужен fork).

Но ACE - это монстр, который еще и труден в правильной сборке на AIX и HP-UX. В нашем случае - это как стрелять из пушки по воробьям.

У нас есть желание пересеть на другую библиотеку. Например, boost. Но это тоже монстр, к тому же монстр, требовательный к свежести компиляторов в плане С++, но мы вынуждены "сидеть" порой на старых компиляторах, так как сотни клиентов их используют. Так что вопрос простоты сборки boost'а тоже под большим вопросом.

Есть и еще вариант - написать все самим на основе системных вызовов, openssl и pthreads. Здесь начинается проблема сопровождения и тщательного тестирования на каждой платформе. С другой стороных - нет зависимости от стороннего почти ненужного монстра (ACE или boost), легкость и прозрачность исходников.

Можно также подобный доморощенный framework выложнить в open-source, и может быть привлечь тем самым сторонних людей для полировки библиотеки.

Хотел бы совета на тему, какую бы такую легковесную библиотеку выбрать, которая бы делала что описано выше, и при этом не была монструозной.
