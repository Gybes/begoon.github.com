---
layout: post
title: "Атомарность типа int и указателя"
language: russian
date: 2010-12-27 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2010/12/int.html
categories:
- cplusplus
- russian
---
Меня давно занимает вопрос атомарности типа `int` (да и любого типа, равного по длине шине процессора, например, указателя или `float` для x86).

Ясно, что в теории, нельзя полагаться на факт такой атомарности. Но давайте конкретизируем: платформа x86, и переменная объявлена как `volatile int a`. Тут я не играюсь с `reinterpret_cast`’ом и приведением указателей, то есть можно гарантировать, что компилятор обеспечит правильное выравнивание, соответствующее шине процессора и памяти, тем самым гарантируя, что доступ к этой ячейке произойдет за один такт.

Есть ли хоть какой-то шанс с ненулевой вероятностью, что какое-то вычисление (команда процессора) по отношению к `а` может быть тут неатомарна? Может ли так быть, что операция `a++` или `a += arbitrary_stuff` и т.д. выполниться не целиком?

Так как переменная `volatile`, значит любые оптимизации будут компилятором запрещены, и не выйдет так, что вместо полноценной 32-х битной команды (обнуления, инкремента, умножения и т.д) компилятор использует, например, каскад двух 8-ми битных команд для операции, которую можно сделать одной 32-х битной.

Ведь где бы значение переменной `а` не обрабатывалось (в регистре, в кэше, в памяти), везде это будет та или иная одиночная команда процесса, которая, очевидно, атомарна.

Ясно, что правилом хорошего тона считается не полагаться на атомарность `int`’а. Но современная архитектура процессоров (микроконтроллеры пока не берем) практически гарантирует эту атомарность, разве нет?
