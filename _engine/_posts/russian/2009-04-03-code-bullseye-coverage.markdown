---
layout: post
title: "Анализатор покрытия кода тестами Bullseye Coverage"
language: russian
date: 2009-04-03 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2009/04/bullseye-coverage.html
categories:
- static code analysis
- russian
---
[Статические анализаторы кода][Статический анализ кода - Coverity, Klocwork], например [Coverity][] или [Klocwork][] являются отличным подспорьем для качественного программирования. 

[Coverity]: http://www.coverity.com/html/prevent-for-c-c++.html
[Klocwork]: http://www.klocwork.com/

Еще одним мощнейшим подспорьем является тестирование. Есть различные виды тестирования — unit-тестирование, функциональное тестирование, регрессивное тестирование и т.д. 

Что понять, насколько хорошо проект покрыт тестами, нужна какая-то количественная мера. Например, это может быть количество предопределенных пользовательских сценариев, которые должны работать как задумано. Это неплохой показатель, и он обычно является основной мерой функционального тестирования и в целом отправной точкой в принятии решения о готовности релиза. Проблема этого подхода, что сами сценарии определены людьми, а значит являются условным и могут содержать ошибки и неточности. Хочется чего-то более объективного и более беспристрастного.

Одним из таких показателей может является количество строк кода, которые были отработаны (выполнены) в процессе тестирования. Эдакая мера для черных дыр в коде, которые никогда не выполняются обычно, а когда таки до них доходит, то все падает. Этот подход вовсе не отменяет функциональное тестирование, а органично дополняется его.

Итак, задача — надо понять, какие части программного коды были задействованы (были выполнены хотя бы раз) в процессе тестирования. 

Представим ситуацию, что тестерам дали задание написать функциональные тесты для новой версии API на основе unit-тестов, написанных программистами, и на основе ожиданий заказчика от этого API. Они написали. А как понять, насколько полно они задействовали своими тестами все укромные уголки кода? Нужен какой-то инструмент.

Мы в компании остановились на [Bullseye Coverage][]. Относительно небольшая цена (для сравнения с Coverity, которая стоила нам несколько десятков кило-зеленых на год, хотя это того стоит). Можно получить тестовый временный ключ для того, чтобы поиграться перед покупкой. Система поддерживает множество основных платформ.

[Bullseye Coverage]: http://www.bullseye.com/

Bullseye Coverage работает на уровне компилятора. Все что нужно — это активировать ее перед компиляцией проекта. После этого бинарные модули проекта будут сохранять в специальном файле статистику по собственной работе (чем-то похоже на работу профилировщика). Откомпилировали, запустили тесты (любые) и посмотрели — какие строки кода были реально выполнены этими тестами.

Bullseye Coverage может показывать задействование на уровне файлов/модулей, функций/классов и просто строк. Открыв файл исходного текста после прогона тестов специальным просмотрщиком можно, например, сказать, что эта конкретная строка или эта функция никогда не вызывалась в процессе тестирования. Порой это очень впечатляет.

Единственное, чего Bullseye Coverage не умеет, так это делать сравнительный анализ нескольких сборок, чтобы бы можно было отследить изменения показателей, а не просто иметь их абсолютные величины.

Лично меня результаты анализа некоторых наших проектов очень впечатлили и, порой, озадачили.

А вас?

Другие посты по теме:

* [Статический анализ кода - Coverity, Klocwork][]

[Статический анализ кода - Coverity, Klocwork]: /blog/russian/2009/02/23/static-code-analysis-coverity-klocwork/
