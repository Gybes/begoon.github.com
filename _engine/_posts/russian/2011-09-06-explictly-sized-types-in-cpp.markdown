---
layout: post
title: "Типы в C++ с явным указанием размера"
language: russian
date: 2011-09-06 00:00
comments: true
blogspot: http://easy-coding.blogspot.com/2011/09/c.html
categories: 
- cplusplus
- russian
---
Наш продукт выпускается на нескольких типах UNIX и на Windows. К счастью, все релизы с этого года только 64-бит, включая Windows (Server 2008 и Studio 2010).

Увы, но наследие 32-х бит сильно мешает и засоряет код. И одна их ключевых проблем - базовые типы.

Сейчас мы пришли к выводу, что зоопарк типов надо прекращать.

Итак, правило.

Слова `char`, `short`, `long`, `long long`, `__int64` по умолчанию запрещены. Их использование придется объяснить на code review. Если нужна переменная, которая логически не является смещением в памяти, и ее предельные значения с запасом укладываются в интервал от -2^31 до 2^31-1, по это просто `int`. Если это индекс или смещение в памяти - это `size_t`.

Если же нужен беззнаковый тип, или конкретный размер, то надо использовать типа из `stdint.h` (`int8_t`, `uint8_t`, `uint16_t`, `int16_t`, `uint32_t`, `int64_t`, `uint64_t`), которые аккуратно реализованы для каждой платформы в одном единственном месте.

Шаг радикальный, посмотрим как пойдет.

Кстати, как вы справляетесь вот с этим?

{% codeblock lang:cpp %}
for (int i = 0; i < s.length(); ++i)
{% endcodeblock %}

Убрать предупреждение о приведении `size_t` к `int` можно, изменив на:

{% codeblock lang:cpp %}
for (size_t i = 0; i < s.length(); ++i)
{% endcodeblock %}

Но как быть с:

{% codeblock lang:cpp %}
for (int i = s.length(); i >= 0; --i)
{% endcodeblock %}

Тут уже на size_t не изменить и надо внучную писать `int i = static_cast<int>(s.length())`, что, конечно, плохо.

Похожая петрушка с `strlen()`, также возвращающей `size_t`.
